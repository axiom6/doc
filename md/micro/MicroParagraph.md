
# Introduction

"Microservices-Based Architecture is a simple concept: it advocates creating a system from a collection of small, isolated services, each of which owns their data, and is independently isolated, scalable and resilient to failure. Services integrate with other services in order to form a cohesive system that’s far more flexible than the typical enterprise systems we build today." Jonas Boner - Reactive Microservice Architecture

## Technological Enablers

"Fast forward to 2016. The technical limitations holding us backfrom Microservices are gone. Networks are fast, disks are cheap(and a lot faster), RAM is cheap, multi-core processors are cheap,and cloud architectures are revolutionizing how we design anddeploy systems. Now we can finally structure our systems with thecustomer in mind. " Jonas Boner - Reactive Microservice Architecture

## Today's Challenges

## The Pyramid of Modern Enterprise Java Development

## Aims and Scope

# What is a Reactive Microservice

## Isolation

Isolation is a prerequisite for resilience and elasticity and requiresasynchronous communication boundaries between services todecouple them in:TimeAllowing concurrencySpaceAllowing distribution and mobility—the ability to move servicesaroundWhen adopting Microservices, it is also essential to eliminate sharedmutable state1 and thereby minimize coordination, contention andcoherency cost, as defined in the Universal Scalability Law2 byembracing a Share-Nothing Architecture.
Isolation is the most important trait. It is the foundation for many ofthe high-level benefits in Microservices. But it is also the trait thathas the biggest impact on your design and architecture. It will, andshould, slice up the whole architecture, and therefore it needs to beconsidered from day one. It will even impact the way you break upand organize the teams and their responsibilities, as Melvyn Conwaydiscovered and was later turned into Conway’s Law in 1967:Any organization that designs a system (defined broadly) will producea design whose structure is a copy of the organization’s communicationstructure.
Isolation between services makes it natural to adopt ContinuousDelivery. This allows you to safely deploy applications and roll outand revert changes incrementally—service by service.Isolation also makes it easier to scale each service, as well as allowingthem to be monitored, debugged and tested independently—somethingthat is very hard if the services are all tangled up in the bigbulky mess of a monolith.
## Autonomous
Insofar as any agent acts on reason alone, that agent adopts and actsonly on self-consistent maxims that will not conflict with othermaxims any such agent could adopt. Such maxims can also beadopted by and acted on by all other agents acting on reason alone.—Law of Autonomy by Immanuel KantIsolation is a prerequisite for autonomy. Only when services are isolatedcan they be fully autonomous and make decisions independently,act independently, and cooperate and coordinate with othersto solve problems.An autonomous service can only promise6 its own behaviour by publishingits protocol/API. Embracing this simple yet fundamental facthas profound impact on how we can understand and model collaborativesystems with autonomous services.Another aspect of autonomy is that if a service only can make promisesabout its own behavior, then all information needed to resolve aconflict or to repair under failure scenarios are available within theservice itself, removing the need for communication and coordination.Working with autonomous services opens up flexibility around serviceorchestration, workflow management and collaborative behavior,as well as scalability, availability and runtime management, atthe cost of putting more thought into well-defined and composableAPIs that can make communication—and consensus—a bit morechallenging—something we will discuss shortly.
## Do One Thing, and Do It WellThis is the Unix philosophy: Write programs that do one thing anddo it well. Write programs to work together.—Doug McIlroyThe Unix philosophy7 and design has been highly successful and stillstands strong decades after its inception. One of its core principles isthat developers should write programs that have a single purpose, asmall well-defined responsibility and compose well with other smallprograms.This idea was later brought into the Object-Oriented Programmingcommunity by Robert C. Martin and named the Single ResponsibilityPrinciple (SRP),8 which states a class or component should “onlyhave one reason to change.”There has been a lot of discussion around the true size of a Microservice.What can be considered “micro”? How many lines of codecan it be and still be a Microservice? These are the wrong questions.Instead, “micro” should refer to scope of responsibility, and theguiding principle here is the the Unix philosophy of SRP: let it doone thing, and do it well.If a service only has one single reason to exist, providing a singlecomposable piece of functionality, then business domains andresponsibilities are not tangled. Each service can be made more generallyuseful, and the system as a whole is easier
## Own Your State, ExclusivelyWithout privacy there was no point in being an individual.—Jonathan FranzenUp to this point, we have characterized Microservices as a set of isolatedservices, each one with a single area of responsibility. Thisforms the basis for being able to treat each service as a single unitthat lives and dies in isolation—a prerequisite for resilience—andcan be moved around in isolation—a prerequisite for elasticity.While this all sounds good, we are forgetting the elephant in theroom: state.Microservices are often stateful entities: they encapsulate state andbehavior, in similar fashion to an Object or an Actor, and isolationmost certainly applies to state and requires that you treat state andbehavior as a single unit.Unfortunately, ignoring the problem by calling the architecture“stateless”—by having “stateless” controller-style services that arepushing their state down into a big shared database, like many webframeworks do—won’t help as much as you would like and only delegatethe problem to a third-party, making it harder to control—both in terms of data integrity guarantees
## Resilience
Resilience—the ability to heal from failure—depends on compartmentalizationand containment of failure, and can only be achievedby breaking free from the strong coupling of synchronous communication.Microservices communicating over a process boundaryusing asynchronous message-passing enable the level of indirectionand decoupling necessary to capture and manage failure, orthogonallyto the regular workflow, using service supervision.
## Embrace Asynchronous Message-Passing
Smalltalk is not only NOT its syntax or the class library, it is noteven about classes. I’m sorry that I long ago coined the term“objects” for this topic because it gets many people to focus on thelesser idea. The big idea is ‘messaging’.—Alan KayCommunication between Microservices needs to be based on AsynchronousMessage-Passing (while the logic inside each Microserviceis performed in a synchronous fashion). As was mentioned earlier,an asynchronous boundary between services is necessary in order todecouple them, and their communication flow, in time—allowingconcurrency—and in space—allowing distribution and mobility.Without this decoupling it is impossible to reach the level of compartmentalizationand containment needed for isolation and resilience.Asynchronous and non-blocking execution and IO is often morecost-efficient through more efficient use of resources. It helps minimizingcontention (congestion) on shared resources in the system,
# Microservices Come in Systems## Systems Need to Exploit Reality## Service Discovery## API Management## Managing Communication Patterns## Integration## Security Management## Minimizing Data Coupling## Minimizing the Cost of Coordination
